################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Read the zproject/README.md for information about making permanent changes. #
################################################################################

from __future__ import print_function
import os, sys
from ctypes import *
from ctypes.util import find_library
import czmq

# application_network
lib = None
# check to see if the shared object was embedded locally, attempt to load it
# if not, try to load it using the default system paths...
# we need to use os.chdir instead of trying to modify $LD_LIBRARY_PATH and reloading the interpreter
t = os.getcwd()
p = os.path.join(os.path.dirname(__file__), '..')  # find the path to our $project_ctypes.py
os.chdir(p)  # change directories briefly

try:
    from application_network import libapplication_network  # attempt to import the shared lib if it exists
    lib = CDLL(libapplication_network.__file__)  # if it exists try to load the shared lib
except ImportError:
    pass
finally:
    os.chdir(t)  # switch back to orig dir

if not lib:
    try:
        # If LD_LIBRARY_PATH or your OSs equivalent is set, this is the only way to
        # load the library.  If we use find_library below, we get the wrong result.
        if os.name == 'posix':
            if sys.platform == 'darwin':
                lib = cdll.LoadLibrary('libapplication_network.0.dylib')
            else:
                lib = cdll.LoadLibrary("libapplication_network.so.0")
        elif os.name == 'nt':
            lib = cdll.LoadLibrary('libapplication_network.dll')
    except OSError:
        libpath = find_library("application_network")
        if not libpath:
            raise ImportError("Unable to find libapplication_network")
        lib = cdll.LoadLibrary(libpath)

class appnet_t(Structure):
    pass # Empty - only for type checking
appnet_p = POINTER(appnet_t)

class appnet_application_t(Structure):
    pass # Empty - only for type checking
appnet_application_p = POINTER(appnet_application_t)


# appnet
lib.appnet_new.restype = appnet_p
lib.appnet_new.argtypes = [c_char_p]
lib.appnet_destroy.restype = None
lib.appnet_destroy.argtypes = [POINTER(appnet_p)]
lib.appnet_is_application_type.restype = c_bool
lib.appnet_is_application_type.argtypes = [appnet_p]
lib.appnet_set_application_type.restype = None
lib.appnet_set_application_type.argtypes = [appnet_p]
lib.appnet_get_application.restype = appnet_application_p
lib.appnet_get_application.argtypes = [appnet_p]
lib.appnet_recive_event.restype = None
lib.appnet_recive_event.argtypes = [appnet_p]
lib.appnet_start.restype = None
lib.appnet_start.argtypes = [appnet_p]
lib.appnet_stop.restype = None
lib.appnet_stop.argtypes = [appnet_p]
lib.appnet_test.restype = None
lib.appnet_test.argtypes = [c_bool]

class Appnet(object):
    """

    """

    allow_destruct = False
    def __init__(self, *args):
        """
        Appnet
        """
        if len(args) == 2 and type(args[0]) is c_void_p and isinstance(args[1], bool):
            self._as_parameter_ = cast(args[0], appnet_p) # Conversion from raw type to binding
            self.allow_destruct = args[1] # This is a 'fresh' value, owned by us
        elif len(args) == 2 and type(args[0]) is appnet_p and isinstance(args[1], bool):
            self._as_parameter_ = args[0] # Conversion from raw type to binding
            self.allow_destruct = args[1] # This is a 'fresh' value, owned by us
        else:
            assert(len(args) == 1)
            self._as_parameter_ = lib.appnet_new(args[0]) # Creation of new raw type
            self.allow_destruct = True

    def __del__(self):
        """
        Destroy the appnet.
        """
        if self.allow_destruct:
            lib.appnet_destroy(byref(self._as_parameter_))

    def __eq__(self, other):
        if type(other) == type(self):
            return other.c_address() == self.c_address()
        elif type(other) == c_void_p:
            return other.value == self.c_address()

    def c_address(self):
        """
        Return the address of the object pointer in c.  Useful for comparison.
        """
        return addressof(self._as_parameter_.contents)

    def __bool__(self):
        "Determine whether the object is valid by converting to boolean" # Python 3
        return self._as_parameter_.__bool__()

    def __nonzero__(self):
        "Determine whether the object is valid by converting to boolean" # Python 2
        return self._as_parameter_.__nonzero__()

    def is_application_type(self):
        """
        Is this appnet an application?
        """
        return lib.appnet_is_application_type(self._as_parameter_)

    def set_application_type(self):
        """
        Set the current appnet to be an application
        """
        return lib.appnet_set_application_type(self._as_parameter_)

    def get_application(self):
        """
        Get the application-object
        """
        return AppnetApplication(lib.appnet_get_application(self._as_parameter_), False)

    def recive_event(self):
        """
        debug: print zyre-event
        """
        return lib.appnet_recive_event(self._as_parameter_)

    def start(self):
        """
        Start the node
        """
        return lib.appnet_start(self._as_parameter_)

    def stop(self):
        """
        Stop the node
        """
        return lib.appnet_stop(self._as_parameter_)

    @staticmethod
    def test(verbose):
        """
        Self test of this class.
        """
        return lib.appnet_test(verbose)


# appnet_application
lib.appnet_application_new.restype = appnet_application_p
lib.appnet_application_new.argtypes = []
lib.appnet_application_destroy.restype = None
lib.appnet_application_destroy.argtypes = [POINTER(appnet_application_p)]
lib.appnet_application_add_view.restype = c_bool
lib.appnet_application_add_view.argtypes = [appnet_application_p, c_char_p]
lib.appnet_application_get_view_list.restype = czmq.zlist_p
lib.appnet_application_get_view_list.argtypes = [appnet_application_p]
lib.appnet_application_add_action.restype = c_bool
lib.appnet_application_add_action.argtypes = [appnet_application_p, c_char_p]
lib.appnet_application_get_action_list.restype = czmq.zlist_p
lib.appnet_application_get_action_list.argtypes = [appnet_application_p]
lib.appnet_application_test.restype = None
lib.appnet_application_test.argtypes = [c_bool]

class AppnetApplication(object):
    """

    """

    allow_destruct = False
    def __init__(self, *args):
        """
        Appnet-Application
        """
        if len(args) == 2 and type(args[0]) is c_void_p and isinstance(args[1], bool):
            self._as_parameter_ = cast(args[0], appnet_application_p) # Conversion from raw type to binding
            self.allow_destruct = args[1] # This is a 'fresh' value, owned by us
        elif len(args) == 2 and type(args[0]) is appnet_application_p and isinstance(args[1], bool):
            self._as_parameter_ = args[0] # Conversion from raw type to binding
            self.allow_destruct = args[1] # This is a 'fresh' value, owned by us
        else:
            assert(len(args) == 0)
            self._as_parameter_ = lib.appnet_application_new() # Creation of new raw type
            self.allow_destruct = True

    def __del__(self):
        """
        Destroy the appnet_application.
        """
        if self.allow_destruct:
            lib.appnet_application_destroy(byref(self._as_parameter_))

    def __eq__(self, other):
        if type(other) == type(self):
            return other.c_address() == self.c_address()
        elif type(other) == c_void_p:
            return other.value == self.c_address()

    def c_address(self):
        """
        Return the address of the object pointer in c.  Useful for comparison.
        """
        return addressof(self._as_parameter_.contents)

    def __bool__(self):
        "Determine whether the object is valid by converting to boolean" # Python 3
        return self._as_parameter_.__bool__()

    def __nonzero__(self):
        "Determine whether the object is valid by converting to boolean" # Python 2
        return self._as_parameter_.__nonzero__()

    def add_view(self, view):
        """
        add application view ( appnet needs to be set as application-type )
        """
        return lib.appnet_application_add_view(self._as_parameter_, view)

    def get_view_list(self):
        """
        get zlist of all views
        """
        return czmq.Zlist(lib.appnet_application_get_view_list(self._as_parameter_), False)

    def add_action(self, action):
        """
        add application action ( appnet needs to be set as application-type )
        """
        return lib.appnet_application_add_action(self._as_parameter_, action)

    def get_action_list(self):
        """
        get zlist of all actions
        """
        return czmq.Zlist(lib.appnet_application_get_action_list(self._as_parameter_), False)

    @staticmethod
    def test(verbose):
        """
        Self test of this class.
        """
        return lib.appnet_application_test(verbose)

################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Read the zproject/README.md for information about making permanent changes. #
################################################################################
